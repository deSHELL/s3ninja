/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package ninja;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import sirius.kernel.health.Log;

import java.io.IOException;
import java.util.Optional;

/**
 * Handles chunks of data which contains signatures generated by the AWS SDK.
 * <p>
 * We currently do not check the signature of each token, as we checked the request signature.
 * This seems to do the job for a test / mock sever for now.
 */
class SignedChunkHandler extends sirius.web.http.InputStreamHandler {

    /**
     * Temporary buffer object used for caching incomplete chunks.
     */
    private final ByteBuf chunkBuffer = Unpooled.buffer();

    @Override
    public void handle(ByteBuf content, boolean last) throws IOException {
        if (!content.isReadable()) {
            super.handle(content, last);
            return;
        }

        // copy everything into the auxiliary buffer first, and try to pull as many complete chunks as possible from it
        // afterwards
        chunkBuffer.writeBytes(content);
        if (tryToCompleteTransfer()) {
            drainAndFlush();
        }
    }

    /**
     * Extracts all complete chunks from {@link #chunkBuffer} and returns a flag indicating whether the entire transfer
     * is complete. The latter case is given when receiving a zero-length chunk.
     *
     * @return flag indicating whether the transfer is complete. If <b>false</b>, continue to invoke the method after
     * more data has been received.
     */
    private boolean tryToCompleteTransfer() throws IOException {
        while (true) {
            int sizeOfChunk = transferNextChunk();

            if (sizeOfChunk == 0) {
                // we have read the last chunk and completed the transfer hence
                return true;
            } else if (sizeOfChunk < 0) {
                // the last chunk could not be read entirely, we need more data
                return false;
            }
        }
    }

    /**
     * Extracts the next chunk from the {@link #chunkBuffer} and returns its size in bytes. If the number is negative,
     * the next chunk is not complete and can not be read yet. The chunk can be processed once more data has been
     * received.
     *
     * @return number of bytes transferred, or negative number if the chunk has not yet been completely transmitted.
     */
    private int transferNextChunk() throws IOException {
        // mark the reader index; we'll jump back if running out of data
        chunkBuffer.markReaderIndex();

        // read the chunk size
        Optional<Integer> optionalLength = readChunkLength(chunkBuffer);
        if (optionalLength.isEmpty()) {
            chunkBuffer.resetReaderIndex();
            return -1;
        }
        int length = optionalLength.get();

        // read the signature
        Optional<String> optionalSignature = readSignature(chunkBuffer);
        if (optionalSignature.isEmpty()) {
            chunkBuffer.resetReaderIndex();
            return -1;
        }

        // before passing on the data, make sure that we have sufficiently many bytes (accounting for the two <CR><LF>
        // characters)
        if (chunkBuffer.readableBytes() < length + 2) {
            chunkBuffer.resetReaderIndex();
            return -1;
        }

        // make sure that the last two bytes are really <CR><LF>
        int index = chunkBuffer.readerIndex();
        byte supposedCR = chunkBuffer.getByte(index + length);
        byte supposedLF = chunkBuffer.getByte(index + length + 1);
        if (supposedCR != '\r' || supposedLF != '\n') {
            throw new IOException("Failed to find expected <CR><LF> characters.");
        }

        // finally pass on the data
        if (length > 0) {
            // we could check the signature here
            ByteBuf data = chunkBuffer.copy(index, length);
            super.handle(data, false);
        }

        chunkBuffer.readerIndex(index + length + 2);
        chunkBuffer.discardReadBytes();

        return length;
    }

    private void drainAndFlush() throws IOException {
        if (chunkBuffer.isReadable()) {
            chunkBuffer.setIndex(0, 0);
            Log.BACKGROUND.WARN("Data found after reading last content chunk. Resetting buffer.");
        }
        super.handle(Unpooled.EMPTY_BUFFER, true);
    }

    /**
     * Reads and parses the chunk length from the given buffer.
     *
     * @param content the buffer to read from.
     * @return an optional containing the chunk length.
     */
    private Optional<Integer> readChunkLength(ByteBuf content) {
        return readRawChunkLength(content).map(string -> Integer.parseInt(string, 16));
    }

    /**
     * Reads a string containing the hex-encoded chunk length from the given buffer.
     *
     * @param content the buffer to read from.
     * @return an optional containing the raw chunk length string.
     */
    private Optional<String> readRawChunkLength(ByteBuf content) {
        StringBuilder chunkLengthString = new StringBuilder();
        while (content.isReadable()) {
            byte data = content.readByte();
            if (data == ';') {
                return Optional.of(chunkLengthString.toString());
            }
            chunkLengthString.append((char) data);
        }

        // reaching this point, we ran out of data prematurely
        return Optional.empty();
    }

    /**
     * Reads and parses the chunk signature from the given buffer.
     *
     * @param content the buffer to read from.
     * @return an optional containing the chunk signature.
     */
    private Optional<String> readSignature(ByteBuf content) {
        return readRawSignature(content).map(string -> {
            if (!string.startsWith("chunk-signature=")) {
                throw new IllegalStateException("Chunk does not conform to compulsory structure.");
            }
            return string.substring(16);
        });
    }

    /**
     * Reads the signature string from the given buffer.
     *
     * @param content the buffer to read from.
     * @return an optional containing the raw chunk signature string.
     */
    private Optional<String> readRawSignature(ByteBuf content) {
        StringBuilder signatureString = new StringBuilder();
        boolean previousWasCR = false;
        while (content.isReadable()) {
            byte data = content.readByte();
            if (data == '\r') {
                previousWasCR = true;
            } else if (previousWasCR && data == '\n') {
                // extract the string, skipping the trailing <CR> character
                return Optional.of(signatureString.substring(0, signatureString.length() - 1));
            } else {
                previousWasCR = false;
            }

            signatureString.append((char) data);
        }

        // reaching this point, we ran out of data prematurely
        return Optional.empty();
    }
}
